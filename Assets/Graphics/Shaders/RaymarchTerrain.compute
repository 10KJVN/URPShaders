#pragma kernel CSMain
#include "Includes/SDFFunctions2.hlsl"

// Output texture
RWTexture2D<float4> Result;

// Camera parameters (set from C#)
float3 _CameraPosition;
float3 _CameraForward;
float3 _CameraRight;
float3 _CameraUp;
float _FieldOfView;
float _AspectRatio;

// Example variables needed for RaymarchTerrain
float frequency = 1.0;        // Define as needed
float amplitude = 1.0;        // Define as needed
float3 treePosition = float3(0.0, 0.0, 0.0); // Set as appropriate for your scene
float trunkHeight = 5.0;      // Set based on your needs
float trunkRadius = 1.0;      // Set based on your needs
float3 moonPosition = float3(0.0, 100.0, 0.0); // Set as appropriate for your moon
float moonRadius = 20.0;       // Set based on your needs

float3 CalculateRayDirection(float2 uv) {
    return normalize(_CameraForward + uv.x * _CameraRight + uv.y * _CameraUp);
}

// Define the RaymarchTerrain function here
float RaymarchTerrain(float3 ro, float3 rd, float frequency, float amplitude, float3 treePosition, float trunkHeight, float trunkRadius, float3 moonPosition, float moonRadius);

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);

    float2 uv = (float2(id.xy) / float2(width, height)) * 2.0 - 1.0;
    uv.x *= _AspectRatio;

    // Calculate ray direction and store in rayDir
    float3 rayDir = CalculateRayDirection(uv);

    // Fixed position and distance for the moon relative to the camera
    const float moonAngleDegrees = 26.0;
    const float moonDistanceFromCamera = 300.0;

    // Calculate moon position in the sky based on angle and camera position
    const float3 moonDirection = normalize(float3(cos(radians(moonAngleDegrees)), 0.3, sin(radians(moonAngleDegrees))));
    moonPosition = _CameraPosition + moonDirection * moonDistanceFromCamera; // Use previously declared variable

    // Call the RaymarchTerrain function to get distanceToTerrain
    float distanceToTerrain = RaymarchTerrain(_CameraPosition, rayDir, frequency, amplitude, treePosition, trunkHeight, trunkRadius, moonPosition, moonRadius);

    float3 color;

    if (distanceToTerrain < 100.0) {
        const float heightFactor = saturate((_CameraPosition.y - distanceToTerrain) / 10.0);
        const float3 ashColor = lerp(float3(0.8, 0.8, 0.8), float3(0.4, 0.4, 0.4), heightFactor);
        color = ashColor;
    } else {
        color = float3(0.0, 0.0, 0.0);
    }

    const float moonRadius = 20.0;
    const float moonDistance = MoonSDF(_CameraPosition, moonPosition, moonRadius);

    if (moonDistance < 0.1) {
        const float3 snowyMintColor = float3(0.875, 0.976, 0.902);
        const float emissiveStrength = 1.5;
        color += snowyMintColor * emissiveStrength;
    }

    Result[id.xy] = float4(color, 1.0);
}
